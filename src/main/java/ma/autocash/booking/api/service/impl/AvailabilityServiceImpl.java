package ma.autocash.booking.api.service.impl;import jakarta.validation.Valid;import ma.autocash.booking.api.dto.AvailabilityDto;import ma.autocash.booking.api.dto.AvailabilityResponseDto;import ma.autocash.booking.api.dto.BookingDto;import ma.autocash.booking.api.entity.Availability;import ma.autocash.booking.api.entity.Booking;import ma.autocash.booking.api.entity.Expert;import ma.autocash.booking.api.entity.Zone;import ma.autocash.booking.api.exception.ApiErrors;import ma.autocash.booking.api.exception.BusinessException;import ma.autocash.booking.api.mapper.AvailabilityMapper;import ma.autocash.booking.api.mapper.BookingMapper;import ma.autocash.booking.api.provider.AvailabilityProvider;import ma.autocash.booking.api.provider.ExpertProvider;import ma.autocash.booking.api.provider.ZoneProvider;import ma.autocash.booking.api.service.AvailabilityService;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.time.LocalDate;import java.time.LocalTime;import java.util.List;@Service@Transactionalpublic class AvailabilityServiceImpl implements AvailabilityService {    private final AvailabilityProvider availabilityProvider;    private final AvailabilityMapper availabilityMapper;    private final ExpertProvider expertProvider;    private final BookingMapper bookingMapper;    private final ZoneProvider zoneProvider;    public AvailabilityServiceImpl(AvailabilityProvider availabilityProvider, AvailabilityMapper availabilityMapper, ExpertProvider expertProvider, BookingMapper bookingMapper, ZoneProvider zoneProvider) {        this.availabilityProvider = availabilityProvider;        this.availabilityMapper = availabilityMapper;        this.expertProvider = expertProvider;        this.bookingMapper = bookingMapper;        this.zoneProvider = zoneProvider;    }    @Override    public void addExpertAvailability(@Valid AvailabilityDto availabilityDto) throws BusinessException {        Availability availability = availabilityMapper.toEntity(availabilityDto);        Expert expert = expertProvider.getExpertById(availabilityDto.getExpertId());        if (expert == null) {            throw new BusinessException(ApiErrors.EXPERT_NOT_FOUND);        }        availability.setExpert(expert);        availabilityProvider.addExpertAvailability(availability);    }    @Override    public void updateAvailability(@Valid AvailabilityDto availabilityDto) throws BusinessException {        Availability existingAvailability = availabilityProvider.getAvailabilityById(availabilityDto.getId());        if (existingAvailability == null) {            throw new BusinessException(ApiErrors.AVAILABILITY_NOT_FOUND);        }        Expert expert = expertProvider.getExpertById(availabilityDto.getExpertId());        if (expert == null) {            throw new BusinessException(ApiErrors.EXPERT_NOT_FOUND);        }        Zone zone = zoneProvider.getZoneById(availabilityDto.getZone().getId());        if (zone == null) {            throw new BusinessException(ApiErrors.ZONE_NOT_FOUND);        }        existingAvailability.setDate(availabilityDto.getDate());        existingAvailability.setStartTime(availabilityDto.getStartTime());        existingAvailability.setEndTime(availabilityDto.getEndTime());        existingAvailability.setExpert(expert);        existingAvailability.setZone(zone);        availabilityProvider.updateAvailability(existingAvailability);    }    @Override    public void deleteAvailability(Long id) throws BusinessException {        Availability existingAvailability = availabilityProvider.getAvailabilityById(id);        if (existingAvailability == null) {            throw new BusinessException(ApiErrors.AVAILABILITY_NOT_FOUND);        }        availabilityProvider.deleteAvailability(id);    }    @Override    public AvailabilityResponseDto getAvailabilityById(Long id) throws BusinessException {        Availability availability = availabilityProvider.getAvailabilityById(id);        if (availability == null) {            throw new BusinessException(ApiErrors.AVAILABILITY_NOT_FOUND);        }        return availabilityMapper.toResponseDto(availability);    }    @Override    public List<AvailabilityResponseDto> getAllAvailabilities() throws BusinessException {        List<Availability> availabilities = availabilityProvider.getAllAvailabilities();        return availabilityMapper.toResponseDto(availabilities);    }    @Override    public List<AvailabilityResponseDto> getAvailabilitiesByExpertAndDate(Long expertId, LocalDate date) throws BusinessException {        List<Availability> availabilities = availabilityProvider.getAvailabilitiesByExpertAndDate(expertId, date);        return availabilityMapper.toResponseDto(availabilities);    }    @Override    public AvailabilityDto createAvailabilityFromBooking(BookingDto bookingDto) throws BusinessException {        Booking booking = bookingMapper.toEntity(bookingDto);        Availability availability = new Availability();        availability.setDate(booking.getBookingDate());        availability.setStartTime(booking.getStartTime());        availability.setEndTime(booking.getEndTime());        Expert expert = expertProvider.getExpertById(booking.getExpert().getId());        if (expert == null) {            throw new BusinessException(ApiErrors.EXPERT_NOT_FOUND);        }        availability.setExpert(expert);        availabilityProvider.addExpertAvailability(availability);        return availabilityMapper.toDto(availability);    }    @Override    public void deleteAvailabilitiesByExpertAndDateAndTimeRange(Long expertId, LocalDate date, LocalTime startTimeStart, LocalTime startTimeEnd) throws BusinessException {        availabilityProvider.deleteAvailabilitiesByExpertAndDateAndTimeRange(expertId, date, startTimeStart, startTimeEnd);    }}